# 문자, 문자열

## 문자

`while(getchar() != "\n" || getchar() != EOF);`

문자 혹은 문자열을 연속으로 받을 때 사용한다.  
문자를 다중으로 받을 때, 다음 문자(열)을 받기 위해 엔터를 치게 되는데,  
이 엔터가 버퍼에 담겨 다음 문자(열)을 받는 곳에 들어가게 된다.

이를 방지하기 위해서, 위 코드를 중간에 삽입한다.

위코드를 사용하여, 다음 문자(열)을 받는 버퍼에 들어갈 엔터를 getchar() 버퍼에 넣는 것이다.

그리고 getchar() 이 엔터가 아니거나, 파일의 끝이 아니면 계속 빈 while문에서 문자열이 있다가, 엔터나 파일의 끝이면 버퍼를 비우는 형태의 코드이다.

예를 들어 6자의 문자열을 받는 `gets 1`과 3자리 문자열을 받는 `get 2`가 나란히 있을 때,
그 사이에 `while`문을 위치시킨다.  
그러면

```
get 1;
while;
get 2;
```

와 같은 형태가 되는데, get 1에서 8자리의 문자열을 입력하고 엔터를 치면,
앞에서부터 6자리 까지만 get 1에 담기고, 나머지 2자리의 문자열과 엔터는 getchar()에 담기고 while 문에서 나오면서 초기화 된다.  
그후 나머지 get 2를 위한 문자열을 받게 되는 것이다.

```
12345678
\n
123
```

이렇게 문자열을 입력했다고 하면,

```
123456
123
```

을 받을 수 있는 것이다.

## 문자열

### 문자열과 포인터

포인터에 특정 문자열 주소를 받을 수 있다.  
이는 문자열은 문자로 이뤄진 배열이기 때문이다.

```c
int a[2] = {1, 2};
int *b = a;
```

위와 같이 배열을 포인터로 받을 때는, 주소연산자(&)를 사용하지 않아도 주소 값을 의미한다.  
배열의 변수는 해당 배열의 첫 번째 주소를 의미하기 때문이다.

이와 마친가지로 문자의 배열인 문자열도 포인터로 문자열을 받을 수 있다.

```c
// 문자열: 주소 연산자 없이 주소에 접근 가능
char str = "hello";
char *pointer = str;

// 포인터로 해당 문자열 자체(해당 첫 문자의 주소)를 받을 수 있음
// 이를 문자열 리터럴 이라고 한다
char *pointer = "hello";
```

그리고 이 `문자열 리터럴`은 읽기 전용으로 메모리에 저장된다.  
그렇기 때문에 해당 포인터 변수에 담긴 내용을 수정할 수 없다.  
문자열 리터럴은 컴파일러가 알아서 메모리 주소를 결정한다.

## scanf() 와 gets()

`scanf()`는 공백을 만날 때까지 char을 받는다.

`gets()`는 공백 포함하고 null(줄바꿈) 만날 때까지 char 받는다.

하지만 `gets()`는 문자열 받는 범위 정하지 않고, 문자열 범위를 넘어가면 벼퍼 이상으로 덮어 쓰기 때문에, 문자열 범위를 정하고, 범위 내에서만 사용할 수 있는 `gets_s()` 사용을 권장한다.

`gets([str])`  
`gets_s([str], [length])`

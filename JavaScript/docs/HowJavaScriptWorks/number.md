# 숫자
여기에선 자바스크립트의 숫자가 움직이는 방식에 대해 설명하는 부분이 많다. 이는 나중에 정리하기로 했고, 부동 소수점, IEEE754 등 컴퓨터 구조 때 배웠던 것들이다.

여기선 자바스크립트의 중요 포인트만 몇 가지 집고 가겠다.

## 유일한 숫자형
자바스크립트는 다른 언어들과는 달리 ::숫자형이 하나::뿐이다.

많은 사람들이 이는 자바스크립트의 단점이라고 생각하지만, 사실 이는 자바스크립트의 아주 큰 강점 중 하나라고 글쓴이는 말하고 있다.

* 비슷한 여러 가지 타입 중에서 혹시  잘못된 타입을 사용할까 봐 고민하며 시간을 낭비하지 않아도 된다. -> 개발자의 생산성 증가
* 타입 변환으로 인한 오류 x
* int형을 사용해서 발생하는 오버플로 문제도 발생하지 않는다. -> 오버플로가 발생하지 않기 때문에 자바스크립트의 정수는 자바의 정수보다 훨씬 안정적이다.

자바스크립트: 2147483647 + 1  2147483648  정확하게 맞음
자바:               2147483647 + 1  -2147483648 완전히 잘못됨

Int형은 오류를 방지하지 못하며, 오히려 오류를 유발할 수 있다.

## 영(0)
자바스크립트에서는 영(0)으로 표시되지만 영(0)이 아닌 값이 있다. 제대로 된 시스템이라면 오직 하나의 영(0)만 있겠지만, IEEE754 표준에서는 0과 -0이라는 두 개의 0이 있다. 자바스크립트는 이 이상한 현상을 숨기기 위해 열심히 노력했으며 거의 성공했다. 

아래와 같은 경우를 제외하면 -0이 존재하는 사실을 무시해도 상관없다.

```js
(1/0) === (1/-0) // false
Object.is(0, -0) // false
```

**Object.is()** 메서드는 두 값이  [같은 값](https://developer.mozilla.org/ko/docs/Web/JavaScript/Equality_comparisons_and_sameness) 인지 결정한다.

## NaN
NaN은 Not a Number를 뜻하지만, typeof 연산자는 NaN을 ’number’형으로 표시하기 때문에 헷갈린다.

### NaN 발생 이유
- [ ] 문자열을 숫자로 변환하려고 했으나 실패
- [ ] 산술 연산자 입력 중에 NaN이 있으면?

NaN과 NaN을 동등 연산자(===)로 비교해보면 false가 나온다.
만약 테스트의 기댓값이  NaN이라면 실제 값이 NaN이라고 해도 항상 실패한다.

값이 NaN인지 아닌지를 테스트하려면 Number.isNaN(value)를 사용하면된다.

Number.isFinite(value)는 값이 NaN, Infinity, -Infinity 인 경우 false를 반환한다.

## Number
숫자를 만드는 함수이다. 자바스크립트의 수는 불변 객체이다. 수에 대한 typeof 연산자는 ‘number’를 반환한다.
Number 함수에는 new를 사용해서는 안된다. 

```js
const good_example = Number("432") 
const bad_example = new Number("432")
typeof good_example          // "number"
typeof bad_example           // "object"
good_example === bad_example //false
```

## 연산자
전위 연산자: 
1.  `+` : 숫자로 변환 -> +(더하기 부호) 전위 연산자는 피연산자를 숫자로 바꾼다. 변환에 실피하면 NaN을 만든다. Number함수가 훨씬 명확하기 때문에 더 선호된다.
2. `-`: 부호 변환 -> -(빼기 부호) 전위 연산자는 피연산자의 부호를 바꾼다. 자바스크립트의 숫자리터럴은 부호가 없다. (-1) 표현식 같이 -(빼기) 부호는 연산자이지 숫자 리터럴의 일부가 아니다.
3. typeof: 타입 확인 -> 연산자가 숫자일 경우 ‘number’라는 문자열을 반환한다. 피연산자가 NaN일 경우에도 마찬가지이다.

중위 연산자:
1. `+`(더하기 부호): 더하기 -> 문자열 연결에도 사용된다 이 오버로딩은 위험성을 가지고 있다. 피연산자가 String이면 나머지 피연산자도 String으로 변환되어진다. 더하기 연산자의 피연산자들이 실제로 숫자들이라서 제대로 더하기 연산이 수행되는지 확인할 때 Number함수가 도움이 된다.
2. `-`(빼기 부호): 빼기
3. `/`(슬래시) : 나누기
4. `%`(퍼센트) : 나머지 -> 자바스크립트는 모듈로 연산자가 없다. 그 대신 나머지(remainder) 연산자가 잇다. 나머지 연산자의 결과는 피제수(나눠지는 수)의 부호를 따른다. 모듈로 연산자는 제수(나누는 수)의 부호를 따른다. 
5. `**`(별표 두 개) : 거듭제곱 -> 자바스크립트는 포트란의 별표 두 개를 차용해 왔다.

#HowJavaScriptWorks 
#HowJavaScriptWorks/숫자
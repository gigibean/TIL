# Regular Expressions
정규 표현식은 문자열에 나타나는 특정 문자 조합과 대응시키기 위해 사용되는 패턴이다. 자바 스크립트에서, 정규 표현식 또한 객체이다. 이 패턴들은 RegExp의 exec 메소드와 test 메소드, 그리고 String 의 match 메소드, replace 메소드, search 메소드, split 메소드와 함께 쓰인다. 

## 정규식 만들기
정규식을 만드는 방법에는 두가지가 있다. 
정규식 리터럴(슬래쉬'/'로 감싸는 패턴)을 사용하는 방법은 다음과 같다.

```js
var re = /ab+c/;
```
정규식 리터럴은 스크립트가 불러와질 때 컴파일된다. 만약 정규식이 상수라면, 이렇게 하는 것이 성능을 향상시킬 수 있다.

다른 방법으로는 `RegExp` 객체의 생성자 함수를 호출하는 방법도 있다.
```js
var re = new RegExp("ab+c");
```
생성자 함수를 사용하면 정규식이 실행 시점에 컴파일된다. 정규식 패턴이 변경될 수 있는 경우, 혹은 사용자 입력과 같이 다른 출처로 부터 패턴을 가져와야 하는 경우에는 생성자 함수를 사용하는 것이 좋다.

## 정규식 패턴 작성하기
정규식 패턴은 `/abc/`와 같이 단순 문자로 구성될 수도 있고, `/ac*c/`또는 `Chapter(/d)\.\d*/`와 같이 단순 문자와 특수문자의 조합으로 구성될 수도 있다.

### 단순 패턴 사용하기
단순 패턴은 무자열을 있는 그대로 대응시키고자 할 때 사용한다. 예를 들어 `/abc/` 라는 패턴은 문자열에서 정확히 'abc'라는 문자들이 모두 함께 순서대로 나타나야 대응된다. 위의 패턴은 'hi, do you knew your abc's'와 'the latest airplane designs envolved form slabsraft' 두가지 예에서 부분 문자열 'abc'에 대응될 것이다. 그러나 'Grab crab' 이라는 문자열에서 'ab c'라는 부분문자열을 포함하고 있지만, 'abc'를 정확하게 포함하고 있지 않기 때문에 대응되지 않는다.

### 특수 문자 사용하기
검색어에서 하나 이상의 b를 찾거나, 혹은 공백을 찾는 것과 같이 '있는 그대로의 대응' 이상의 대응을 필요로 하는 겅우, 패턴에 특수한 문자를 포함시킨다. 예를 들어 `/ab*c/` 패턴은 `a`문자 뒤에 0개 이상의 문자 `b`(`*` 문자는 바로 앞의 문자가 0개 이상이란ㄴ 것을 의미한다.)가 나타나고 바로 뒤에 문자 `c`가 나타는 문자 조합에 대응되낟. 문자열 'cbbabbbbcdebc'에서 위의 패턴은 부분 문자열 'abbbc'와 대응된다.

#### 정규식에서의 특수문자
|문자|의미|
|--|--|
|`\`|특수문자가 아닌 문자 앞에서 사용된 백슬래시는 해당 문자는 특별하고 문자 그대로 해석하면 안된다는 사실을 가리킨다. 예를 들어 앞에 \가 없는 b는 보통 소문자 b 가 나오는 패턴과 대응된다. 그러나 \b자체는 어떤 문자와도 대응되지 않는다. 이문자는특별한 단어 경계 문자를 형성한다.    특수 문자 앞에 위치한 백슬래시는 다음에 나오는 문자는 특별하지 않고 문자 그대로 해석되어야 한다는 사실을 가리킨다 .예를 들어 패턴 `/a*/`와 같은 패턴을 생성자로 만들려면 `new RegExp('a\\*')`와 같이 백슬래시 자체를 이스케이프 시켜주어야 한다.|
|`^`|입력의 시작 부분에 대응된다. 만약 다중행 플래그가 참으로 설정되어 있다면, 줄 바꿈 문자 바로 다음 부분과도 대응된다. 예를들어 `/^A/`는 'an A'의 'A'와 대응되지 않는다. 그러나 "An E"의 'A'와는 대응된다. '`^`'가 문자셋([abc])패턴의 첫 글자로 쓰인다면 그 때는 전혀 다른 의미를 가진다.|
|`$`|입력의 끝 부분과 대응한다. 만약 다중행 플래그가 참으로 설정되어 있다면, 줄 바꿈 문자의 바로 앞 부분과도 대응된다. 예를 들어 `/t$/`는 'eater'의 't'와 대응하지 않는다. 그러나 'eat'의 't'와는 대응된다.|
|`*`|앞 표현식 이 0회 이상 연속으로 반복되는 부분과 대응된다. {0,}과 같은 의미이다. 예를 들어 `/b*/`는 'A ghost booooed'의 'boooo'와 대응되고, "A bird warbled'의 'b'와 대응되지만 "A goat grunted"내의 어느 부분과도 대응되지 않는다.|
|`+`|앞의 표현식이 1회 이상 연속으로 반복되는 부분과 대응된다. {1,}와 같은 의미이다. 예를 들어 `/a+/`는  "candy"의 'a'와 대응되고, "caaaandy"의 모든 'a'에 대응되지만, "cndy"내의 어느 부분과도 대응되지 않는다.|
|`?`|앞의 표현식이 0 또는 1회 등장하는 부분과 대응된다. {0, 1} 와 같은 의미이다. 예를들어, `/e?le?/`는 "angel"의 'el'에 대응되고, "angle"의 "le"에 대응디고 또한 "oslo"의 "l"에 대응된다. 만약 수량자 *, +, ?, {} 바로 뒤에 사용하면 기본적으로 탐욕수럽던(가능한 한 많이 대응시킴) 수량자를 탐욕스럽지 않게(가능한 가장 적은 문자들에 대응시킴) 만든다. 예를들어, `/\d+/`를 "123abc"에 적용시키면 "123"과 대응된다. 그러나 `/\d+?/` 를 같은 문자열에 적용시키면 오직 '1'과만 대응된다. 또한 이문자는 `x(?=y)`와 `x(?!y)` 항목에서 설명하는 바와 같이 사전 검증을 위해서도 쓰인다.|
|`.`|개행 문자를 제외한 모든 단일 문자와 대응된다. 예를들어 `/.n/`은 "nay, an apple is on the tree"에서 "an"과 "on"에 대응되지만, 'nay'에서는 대응되지 않는다.|
|`(x)`|다음의 예제가 보여주는 것 처럼 'x'에 대응되고, 그것을 기억한다. 괄호는 포획괄호라고 불린다. 패턴 `/(foo) (bar) \1\2/`안에 `(foo)`와 `(bar)`는 문자열 "foo bar foo bar"에서 처음의 두 단어에 대응되고 이를 기억한다. 패턴 내부의 `\1`과 `\2`는 문자열의 마지막 두 단어에 대응된다. \n 패턴은 앞의 n번째 포획 괄호에 대응된 문자열과 똑같은 문자열에 대응된다. `\1 \2 ,\n`과 같은 문법은 정규식의 패턴  부분에서 사용된다. 정규식의 치환부분에서는 `$1, $2, $n`과 같은 문법이 사용되어야 한다. 예를들어 `'bar foo'.replace(/(...) (...)/, '$2 $1')`와 같이 사용되어야 한다. `$&` 패턴은 앞에서 대응된 전체 문자열을 가리킨다.|
|`(?:x)`|'x'에 대응되지마 대응된 것을 기억하지 않는다. 괄호는 비포획 괄호라고 불리고, 정규식 연산자가 같이 동작할 수 있게 하위 표현을 정의할 수 있다. 정규식 예제 `/(?:foo){1,2}/`을 생각해보자. 정규식이 `/foo{1,2}/`라면, {1,2}는 'foo'의 마지막 'o'에만 적용된다. 비포획 괄호가 같이 쓰인다면, {1,2}는 단어 'foo'전체에 적용된다.|
|`x(?=y)`|오직 "y"가 뒤따라오는 'x'만 대응된다. 예를들어 `/Jack(?=Sprat)/` 은 'Sprat' 가 뒤따라오는 'Jack'에만 대응된다. `/Jack(?=Sprat|Frost)/`는 'Sprat'또는 'Frost'가 뒤따라오는 'Jack'에만 대응된다. 그러나 'Sprat'및 'Frost'는 대응 결과의 일부가 아니다.|
|`x(?!y)`|'x'뒤에 'y'가 없는 경우에만 'x'에 일치한다. 예를 들어 `/\d+(?!\.)/`는 소숫점이 따라오지 않는 숫자에 일치한다. 정규식 `/\d+(?!\.)/.exec("3.14")`는 <p color="red">'3.14'가 아닌 '14'에 일치한다.</p>|
|`x|y`|'x'또는 'y'에 대응한다. 예를들어 `/green|red/`는 'green apple'의 'green'과 대응되고, 'red apple'의 'red'와 대응된다.|
|`{n}`|앞 표현식이 n번 나타나는 부분에 대응된다. n은 반드시 양의 정수여야 한다. 예를 들어 `/a{2}/`는 'candy'의 'a'에 대응되지 않지만, 'caandy'의 모든 a와, 'caaaandy'의 첫 두 'a'에는 대응된다|
|`{n, m}`|`n`과 `m`은 양의 정수이고, `n <= m`을 만족해야한다. 앞 문자가 최소 n개 최대 m개가 타나나는 부분에 대응된다. m이 생략된다면 m은 무한대로 취급된다. 예를들어 `/a{1,3}/`은 'cndy'에서 아무것도 대응되지 않지만, 'caandy'의 첫 두 a와 'caaaaandy'의 첫 세 a에 대응된다.|
|`[xyz]`|문자셋이다. 이 패턴 타입은 괄호 안에 어떤 문자(이스케이프 시퀀스까지 포함)와도 대응된다. 점(.)이나 별표(*)같은 특수문자는 문자셋 내부에서는 특수문자가 아니다. 따라서 이스케이프시킬 필요가 없다. 하이픈을 사용하여 문자의 범위를 지정해줄 수 있다. 예를들어 패턴 `[a-d]`는 패턴 `[abcd]`와 똑같이 작동하며, "bisket"의 'b'와 일치하고, 'city'의 'c'와 일치한다. 패턴 `/[a-z]+/`와 `/[\w.]+/`는 'test.i.ng'전체 문자열이 일치한다.|
|`[^xyz]`|부정 문자셋 혹은 보충 문자셋이라고 한다. 괄호 내부에 등장하지 않은 어떤 문자와도 대응된다. 하이픈을 이용하여 문자의 범위를 지정할 수 있다. 일반적인 문자셋에서 작동하는 모든 것은 여기에서도 작동한다. 예를 들어, 패턴 `[^abc]`는 패턴 `[^a-c]`와 동일하다. 두 패턴은 'brisket'의 'r', 'chop'의 'h'와 대응된다.|
|`[\b]`|백스페이스(U+0008)에 대응된다. 이와 같이 백스페이스 문자 리터럴에 대응시키려면, 대괄호([])를 이용해야한다.|
|`\b`|단어 경계에 대응한다. 단어 경계는 다른 단어문자가 앞이나 뒤에등장하지 않는 위치에 대응된다. 단어의 경계는 대응 결과에 포함되지 않는다. 다른 말로는, 단의 경계에 대응되는 문자열의 길이는 항상 0 이다. 예를들어 `/\bm/`은 'moon'의 'm'에 대응한다. `/oo\b/`는 'moon'의 'oo'부분에 대응되지 않는데, 왜냐하면 ,'oo'를 뒤따라오는 'n'이 단어 문자이기 때문이다. `/oon\b/`은 'moon'의 'oon'에 대응된다. 왜냐하면, 'oon'은 문자열의 끝이라서 뒤따라오는 단어 문자가 없기 때문이다. `/\w\b\w/`는 어떤 것에도 일치하지 않는다. 왜냐하면 단어 문자는 절대로 비 단어 문자와 단어 문자 두개가 뒤따라 올 수 없기 때문이다.|
|`\B`|단어 경계가 아닌 부분에 대응된다. 문자열의 첫번째 문자가 단어가 아닌 경우 해당 문자 앞 부분에 대응된다. 문자열의 마지막 문자가 단어 문자가 아닌  경우 해당 문자의 뒷부분에 대응된다. 두 단어 사이에 대응된다. 단어 문자가 아닌 두 문자 사이에 대응된다. 빈 문자열에 대응된다. 문자열의 시작 부분과 끝 부분은 단어가 아닌 것으로 간주된다. 예를 들어 `/\B../`은 'noonday'의 'oo'와 대응되며, `/y\B./`는 'possibly yesterday'의 'ye'와 대응된다.|
|`\cX`|문자열 내부의 제어 문자에 대응된다. 여기서 X는 A에서 Z까지의 문자 중에 하나이다.|
|`\d`|숫자 문자에 대응된다. [0-9]와 동일하다.|
|`\D`|숫자 문자가 아닌 문자에 대응된다. [^0-9]와 동일하다|
|`\s`|스페이스, 탭, 폼피드, 줄 바꿈 문자등을 포함한 하나의 공백 문자에 대응된다.|
|`\S`|공백 문자가 아닌 하나의 문자에 대응되낟.|
|`\t`|탭 문자에 대응된다.|
|`\v`|수직 탭 문자에 대응된다|
|`\w`|밑줄 문자를 포함한 영숫자 문자에 대응된다. [A-Za-z0-9_]와 동일하다. 여기에 대응되는 문자를 단어 문자라고한다. 예를들어 `/\w/`는 'apple'에 'a'에 대응된다.|
|`\W`|단어 문자가 아닌 문자에 대응된다. [^A-Za-z0-9_]와 동일하다.|
|`\n`|정규식 내부의 n번째 괄호에서 대응되는 부분에 대한 역참조이다. 여기서 n은 양의 정수이다. 예를 들어 `/apple(,)\sorange\1/`은 'apple, orange, cherry, peach'의 'apple, orange'에 일치한다|
|`\0`|널 문자에 대응한다 이때 다른 숫자를 뒤에 쓰면 안된다. 왜냐하면 `\0<digits>`는 8진 이스케이프 시퀀스이기 때문이다.|

### 괄호를 사용하기
정규식 내부의 일부를 둘러싼 괄호는 해당 부분에서 대응된 문자열을 기억하는 효과를 갖는다. 기억된 문자열은 이후에 다른 곳에서 사용하기 위하여 불러와 질 수 있다. 예를 들면 패턴 `/Chapter (\d+)\.\d*/`는 패턴의 일부분이 기억될 거라는 사실을 나타낸다. 이 패턴은 하나 이상의 숫자 (`\d`는 숫자를 의미하고 +는 1개이상을 의미한다)이후에 하나의 소숫점(\가 붙은 소숫점은 문자 그대로의 문자 '.'에 대응됨을 나타낸다), 그 두에 0개 이상의 숫자(\d는 숫자, *은 0개 이상을 의한다)가 뒤따라오는 'Chapter'문자열에 대응된다. 더해서 괄호는 처음으로 일치하는 숫자 문자를 기억하기 위해서 사용되었다.  

이 패턴은 'Open Chapter 4.3, paragraph 6'에 나타나며 '4'가 기억된다. 이 패턴은 'Chapter 3 and 4'에서는 나타나지 않는다. 왜냐하면 문자열이 '3'이후에 마침표를 가지고 있지 않기 때문이다. 

부분 문자열을 대응시키면서도 해당 부분을 기억하지 않으려면, 괄호의 첫머리에 ?: 패턴을 사용하자. 예를 들어 (?:\d+)는 1개 이상의 숫자에 대응되지만 해당 문자들을 기억하지 않는다.

## 정규식 사용하기
정규식은 RegExp, test, exec, String, match, replace, search, split 메소드와 함께 쓰인다.

### 정규식에서 쓰이는 메소드
|메소드|설명|
|--|--|
|exec|대응되는 문자열을 찾는 RegExp 메소드이다. 정보를 가지고 있는 배열을 반환한다. 대응되는 문자열을 찾지 못했다면 null을 반환한다. 예를들어 `/\d+(?!\.)/.exec("3.14")`는 [14] 배열을 반환하게 된다.|
|test|대응되는 문자열이 있는지 검사하는 RegExp 메소드이다. true나 false를 반환한다.|
|match|대응되는 문자열을 찾는 RegExp메소드이다. 정보를 가지고 있는 배열을 반환한다 대응되는 문자열을 찾지 못했다면 null을 반환한다.|
|search|대응되는 문자열이 있는지 검사하는 String메소드이다. 대응되는 부분의 인덱스를 반환한다. 대응되는 문자열을 찾지 못했다면 -1을 반환한다.|
|replace|대응되는 문자열을 찾아 다른 문자열로 치환하는 String메소드이다.|
|split|정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 String이다.|
문자열 내부에 패턴과 대응되는 부분이 있는지 알고 싶다면, test(대응되는 문자열 있나 boolean)나 search(대응되는 문자열의 인덱스 반환) 메소드를 사용하자. 좀 더 많은 정보를 원한다면 (대신 실행이 조금 느리다) exec(대응되는 문자열 찾아 배열로 혹은 null)이나 match(대응되는 문자열 찾아 배열 혹은 null)를 사용하면된다.

```js
var myRe = new RegExp("d(b+)d", "g");
// or
// var myRe = /d(b+)d/g;
var myArray = myRe.exec("cdbbdbsbz");
```

myArray는 `['dbbd', 'bb', index: 1, input: 'cdbbdbsbz']` 이라는 결과가 나오고, 각각
* 대응된 문자열 및 기억한 모든 부분 문자열 
* `index`: 입력된 문자열에서 대응된 부분에 해당하는 인덱스(0 부터 시작)
* `input`: 입력된 원본 문자열
* `[0]`: 마지막으로 대응된 문자열 "dbbd"

myRe
* lastIndex: 다음 검색 시 검색을 시작할 인덱스(g 옵션) 5
* source: 패턴 문자열 정규식이 생성될 때 갱신된다. "d(b+)d"

### 괄호로 둘러싼 패턴 사용하기
정규식 패턴에 괄호를 사용하면 그부분을 별도로 대응시키면서 대응된 부분을 기억한다. 예를 들면, `\a(b)c/`는 'abc'와 대응되면서 'b'를 기억한다. 괄호로 감싸진 문자열을 불러오려면, 배열 요소 [1]...[n]을 사용하면된다.

괄호로 감쌀 수 있는 문자의 개수에는 제한이 없다. 반환된 배열은 찾아낸 모든 것들을 갖고 있다. 다음의 예는 괄호로 둘러싸진 부분이 어떻게 대응되는지 보여준다.

다음의 예는 문자열 내부의 단어를 바꾸기 위해 relpace() 메소드를 이용하고 있다. 치환 문자열로는 $1과 $2를 사용하고 있는데 이는 각각 첫번째와 두번째 괄호가 처진 부분에 대응된 문자열을 가리킨다.

```js
var re = /(\w+)\s(\w+)/;
var str = 'John Smith';
var newstr = str.replace(re, "$2, $1");
console.log(newstr);
// "Smith, John"
```

### 플래그를 사용한 고급검색
정규식은  여섯 개의 플래그를 설정해줄 수 있으며, 이를 통해 전역 검색 또는 대소문자 구분 없는 검색을 수행할 수 있다. 이 플래그들은 각기 사용될 수도 있고 함께 사용될 수도 있고 순서에 구분이 없다.

#### Regular expression flags
|flag|description|
|--|--|
|g|전역 검색|
|i|대소문자 구분 없는 검색|
|m|다중행(multi-line)검색|
|s|`.`에 개행문자도 매칭|
|u|유니코드, 패턴을 유니코드 코드 포인트의 나열로 취급한다|
|y|"sticky"검색을 수행, 문자열의 현 위치부터 검색을 수행한다.|
정규식 플래그를 포함시키려면 아래 문법을 사용하면 된다.
```js
var re = /pattern/flags;
```

```js
var re = new RegExp("pattern", "flags");
```
이 플래그는 정규식에 함쳐지는 정보임을 기억하는게 좋다. 이것들은 나중에 추가되거나 제거될 수 없다.
예를 들어 `re = /\w+\s/g`는 한개 이상의 문자열 뒤에 공백이 하나 있는 패턴을 찾는 정규식을 생성한다. 그리고 문자열 전체에 걸처 이 조합을 검색한다.

```js
var re = /\w+\s/g;
// or
// var re = new RegExp("\\w+\\s", "g");
var str = "fee if fo fum";
var myArray = str.match(re);
console.log(myArray);

// ["fee ", "fi ", "fo "]
```

`.exec()` 메소드를 사용할 대에는 'g' 플래그에 대한 동작이 다르다. ("클래스"와 "인수"의 역할이 뒤바뀐다. `.match`를 사용할 때는 string클래스가 메소드를 갖고 정규식은 인수였던 것에 반해 `.exec()`를 사용할 때는 정규식이 메소드를 갖고 문자열이 인수가 된다 즉, `str.match(re)`, `re.exec(str)`) 'g' 플래그와 `.exec()`메소드가 함께 사용되면 진행상황에 대한 정보가 반환된다.
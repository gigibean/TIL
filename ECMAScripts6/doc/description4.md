# 임시객체, 배열객체

## Number, String, Boolean 객체 타입
이러한 타입들은 따로 타입을 지정하지 않더라고 해도, 자동으로 es6에서는   
자동으로 지정이 됩니다.
이러한 타입을 '동적 타입핑' 이라고 합니다.   
```
let foo = 4;
```
foo가 자동으로 Number 타입으로 변경됩니다.   
JS에서는 동적으로 타입이 지정됩니다.
이는 프로그래밍이 처리되는 과정에서 자동으로 파악하여 동적으로 타입을 지정한다는 의미 입니다.

```
let foo = "bar";
```

형태는 원시타입입니다. 
변수, 상수 지정할 때 타입지정을 안했었는데, 그 이유도 JS에서 동적으로 타입을 지정하기 때문입니다.
이러한 원시타입에 대응되는 객체 타입으로는 Number, String, Boolean이 있습니다.

## 왜 원시타입에 대응되는 이러한 객체가 필요할까요?
1. 어떤 특별한 값을 저장하고자 할때 이러한 객체를 사용합니다.
Number라는 객체는 말그대로 객체이니까 안에 해당되는 property와 객체가 가지고 있는 함수(method)를   
담고 있는 컨데이너 입니다.   
복잡한 값들을 표현할 수 있는 것이 객체이기 때문에 Number라는 객체 안에
여러 함수나 프로퍼티를 가질 수 있습니다. 

```
Number.INFINITY
```

이런식으로 접근해서 특별한 프로퍼티를 가질 수 있습니다.

2. 어떤 필요한 함수 기능을 사용하자 할 떄 객체를 활용할 수 있습니다.
원시타입에서는 이러한 함수나 프로퍼티를 사용할 수 없기 때문에 이런 것은 특별한 기능과 값을 
가지고 사용하고자 할 때 이러한 객체를 사용할 수 있습니다.


## 임시 객체

```
const s = "Hello world";
```
여기서 s는 단순한 문자열 타입으로 되어있는 원시 타입입니다.   
이 s라고 하는 문자열 원시타입의 상수를 객체처럼 사용할 수 있습니다.

```
s.toUpperCase()'
```
<br/>

return
```
"HELLO WORD"
```

단순한 상수가 마치 객체처럼 객체 함수에 접근할 수 있도록 접근연산자(.)를 이용해서 함수를 호출하고 있습니다.   
마치 s라는 객체가 함수를 가지고 있는 객체처럼 보입니다.   
이는 JS에서는 이렇게 문자열에 대응되는 객체. 즉, String 객체를 일시적으로 만들어 호출한 것입니다.
<br/>
함수를 호출할 때만 만들어지는 객체이므로 그 후에는 이 임시객체는 즉시 객체를 파기시킵니다.   
호출할 때만 만들어지고 호출 후에는 사라지는 것 입니다.
이는 

```
cnosole.log(s);
```
를 해보면 알 수 있습니다.
<br/>

return 
```
hello world
```

객체는 Obect{key : value, .. } 형태인 것에 비해 임시로 객체를 호출하고 되돌아와 다시 원시타입이 됩니다.   

<br/>

```
const s1 = "World";
sl.length
```

임시 객체가 호출되어 객체처럼 필드를 가져올 수 있습니다.

```
s1.aa = "aa";
s1.aa;
```
<br/>
return

```
undefined
```

위 예시처럼 JS에서는 일시적으로 객체를 만들었다가 프로퍼티나 함수를 호출하고 난 후에는 그 객체를 파기 시키는 특징이 있습니다.

```
s1.length
```
<br/>
return

```
5
```
이 경우에는 스트링 객체 안에 포함되어 있는 프로퍼티이기 때문에 String 객체가 가지고 있는 프로퍼티를 사용하는 것이기 때문에 사용할 수 있는 것입니다.
그러나 s1.aa는 사용자가 임의로 추가 시킨 프로퍼티기 때문에 사실은 존재하지 않는 객체에는 추가할 수 없는 것입니다.

<br/>

대응되는 객체를 매치해서 필요한 객체를 임시적으로 사용하는 것입니다.   
원시타입 같은 경우는 사용할 수 없는 함수나 프로퍼티를 임시 객체를 활용해 사용할 수 있게 됩니다.

<br/>

## 배열 객체
일반적인 객체와는 다르게 항상 순서가 들어가고 key 는 순차적인 숫자를 갖게 되고 여러가지 배열에 관한 메서드를   
가지고 있습니다. 
JS 배열은 배열의 크기가 고정되어 있지 않습니다. 언제든 요소를 추가하거나 제거할 수 있습니다.   
그리고 배열 안에 각각의 요소에 대한 데이터 타입을 가지리 않고 사용할 수 있습니다.   
C, Java 등의 언어는 사용전에 형태의 선언이 필요하나, JS는 필요없습니다.   
<br/>
JS의 배열 또한 0부터 시작합니다.
배열의 리터럴을 표현할 때 

```
const a1 = [1, 2, 3, 4];
a1;
```
<br/>

return
```
(4)[1,2,3,4]
```
<br/>

```
const a2 = [1, 'two', 'three', null]
a2
```
<br/>
return

```
(4)[1, 'two', 'three', null]
```
<br/>
물론 배열을 사용할 때 멀리라인으로 사용할 수도 있습니다.   

배열 안에는 원시타입형태로 각각의 값을 넣을 수도 있지만 객체로 넣어줄 수도 있습니다.

```
const a4 = [
    {name : "Kim", level : 3},
    {name : "Lee", level : 2},
    {name : "Park", level: 4},
];
a4
```

<br/>
return

```
(3)[Objet, Object, Object]
```

<br/>
배열 안에 배열을 넣을 수도 있습니다.

```
const a5 = [
    [1, 3, 4, 5],
    [2, 7, 8, 9],
];
a5
```
<br/>
return

```
(2)[Array(4), Array(4)]
```

배열 객체는 length 필드를 사용할 수 있습니다.

```
a5.length
```
<br/>

return

```
2
```

<br/>

배열의 요소에 접근하기 위해서는 대괄호 안에 인덱스를 넣으면 됩니다.

```
a2[0]
```
<br/>

return

```
1
```

```
a3[a3.length - 1]
```

이렇게 사용하면 마지막 값을 사용할 수 있습니다.

<br/>

```
a1[3] = 100;
a1;
```
<br/>

return

```
(4)[1, 2, 3, 100]
```

배열의 요소의 값을 변경하기 위해서는 해당 값에 인덱스로 접근해서 값을 바꾸어주면 됩니다.
# 연산자
산술 연산자, 비교 연산자, 논리 연산자, 할당 연산자, 조건 연산자 등이 있습니다.   

## 산술 연산자
+, - *, %. / 연산자가 있습니다.
단항 연산자, 전위 연산자, 후위 연산자

### 단항 연산자

```
const il = 120;
const i11 = 200 - - il;
```

result

```
320
```

이는 -i1 이 -120 이되고 거기에 -를 해서 +로 바뀌면서 200 + 120 이 되어 320 이라는 값이 출력됩니다.

<br/>

```
const ss = "5";
y = 3 + +ss;
```

result

```
8
```

만약에 +를 사용하지 않는다면

```
y = 3 + ss;
```

result

```
"35"
```

이렇듯 string 변수 앞에 +나 -를 사용하지 않는다면 숫자형 값인 3이 문자형으로 변환되어   
문자형의 병합이 됩니다.

<br/>

### 전위 연산자, 후위 연산자
증감 연산자를 변수 앞에 사용하는 것을 전위 연산자라고 합니다.   
증감 연산자를 변수 뒤에 사용하는 것을 후위 연산자라고 합니다.   

### 후위 연산자

```
r1 = y--;
```

result

```
8
```

분명히 연산자를 사용하였지만 변수 값에는 변화가 없습니다.

```
r1 = y-- + y--;
```

result

```
13
```

현재 와이 갑은 8입니다.   
그렇다면 

```
7-- + 6--
```
와 같습니다.   

이는 처음 연산한 

```
r1 = y--;
```
에서 출력 값은 8 이지만 출력 이후 y는 --연산자에 의해 7이 되었습니다.   
그 후에 

```
r1 = y-- + y--;
```

에서 첫번재 y는 7이 되어 있고 더하기(+)가 진행되기 전에 y는 6이 됩니다.
그래서 최종적으로 

```
(8-1) + (7-1) 
```

이 되어 13이라는 값이 출력되는 것입니다.   
그 후에 두번째 y--에 의해 y 는 5라는 값을 가지고 있을 것입니다.   
그래서 현재 y는

```
y
```

result

```
5
```

입니다.   

### 전위 연산자

이제 전위 연산을 사용해 보겠습니다.

```
++y
```

result

```
6
```

입니다.   
이는 현재 y의 값은 5인데 전위 연산자를 사용하여 출력되기 전에 +1이 됩니다.
그렇기 때문에 출력 값은 5+1 인 6이 됩니다.

```
r1 = --y + --y;
```

result

```
9
```
이는 전위 연산자를 사용했기 때문에 전위 연산이 먼저 진행되기 때문입니다.
여기서 첫번째 y는 6에서 전위 연산자인 -1 을 만나서 5가 됩니다.   
두번째 y가 가지고 있는 값인 5에서 전위 연산자를 만나서 -1이 되고 5-1 인 4가 됩니다.   
최종적으로 5+4 인 9가 출력됩니다.

<br/>

## 비교 연산자
    === 은 데이터의 타입과 실제 값 등 모두 같을 때 사용하며 '엄격한 동등(Strict Equality)' 라고 합니다.
    == 은 '느슨한 동등(Loose Equality)'라고 합니다.
    대소 관계를 나타내는 연산자까지 비교 연산자는 3개로 구성되어 있습니다.

염격한 동등(===)은 완전히 일치하는 경우 사용합니다.    
동등 관계(==)같은 경우 예를 들어 "34"와 34 가 있을 때 이 둘은 동등 관계에 있다고 볼 수 있습니다. 
하지만 반대로 일치(===)는 아닙니다.

```
"34" == 34
```

result

```
true
```

<br/><br/>

```
"34" === 34
```

result

```
false
```
<br/> <br/>

```
n1 = 5;
n2 = "5";
n1 === n2;
n1 !== n2;
```

result

```
false
true
```

<br/>

일치하는 지 비교하기 위해서는 일치(===)연산자를 이용합니다. 그 반대로 일치하지 않는다는 의미는 (!==)를 사용합니다.   
동등하지 않다라는 의미가 아니라 일치하지 않는다라는 비교 연산자는 (!==) 입니다.   

그렇다면 Number함수를 이용해서 숫자로 변형을 해보겠습니다.

```
n1 === Number(n2);
```

result

```
true
```

Number 생성자에 의해서 숫자 형으로 바뀌었기 때문에 일치한다고 나옵니다.
<br/>

```
n1 !== Number(n2);
```

result

```
false
```

둘은 일치하기 때문에 위 연산은 false값을 반환합니다.

<br/>

```
n1 == n2
```

result

```
true
```

타입은 다르지만 값은 같기때문에 동등하다고 볼 수 있습니다.

```
n1 != n2
```

result

```
false
```

동등한지 비교하는 연산자 (==)의 반대는 (!=) 입니다.   

객체를 통해서 비교 연산을 해보겠습니다.

```
const n3 = {name : "n3 object"};
const n4 = {name : "n3 object"};
n3 === n4
```

이 경우 안에 있는 값은 똑같습니다. 위는 일치할까요?

result

```
false
```

객체는 모두 다 유일한 것이기 때문입니다.
A객체와 B객체가 있다면 이 둘은 다른 객체입니다.

예를들어 Person객체를 이용해서 a객체와 b객체를 생성했다면 a와 b는 같은 객체가 될 수 없습니다.   
안에 있는 프로퍼티가 같다고 해도 객체는 각각 다르며 유일 합니다.

그럼 이 둘이 동등하냐고 물어보면 이는 동등할까요?

```
n3 == n4
```

result

```
false
```

위 결과처럼 동등하지도 않습니다. 앞서 원시값과 비교했을 때도 다른 경우입니다.   
__객체 비교는 서로 동등하거나 일치하지도 않습니다.__   

### false
    undefined, null, 0, NaN, ""(빈문자열) 모두 false에 해당이 됩니다.

<br/>
숫자형이 NaN인지 알고 싶다면 __isNaN()__ 이라는 함수를 사용하면 됩니다. 숫자가 아니라면 true를 반환하고 숫자가 맞다면 false를 반환합니다.   
NaN은 숫자가 아니라는 의미 입니다.   

```
isNaN(NaN);
```

result

```
true
```
<br/><br/>

```
isNaN('foo');
```

result

```
true
```

<br/><br/>

```
isNaN('0');
```

문자형인데 true가 나올까요 false가 나올까요?

result

```
false
```
숫자가 맞다며 false가 나옵니다.   
그냥 숫자 0을 넣으면 어떻게 될까요?

```
isNaN(0);
```

result

```
false
```
당연히 숫자이기 때문에 false가 나옵니다.   
__결론적으로 문자열 숫자도 NaN이 아니라는 의미 입니다.__

<br/>

```
isNaN('12');
```

result

```
false
```

다른 문자열 숫자를 넣어도 false가 나옵니다.   
이런식으로 JS에서는 NaN을 정의하고 있습니다.